{
  "author": {
    "name": "Eirik Albrigtsen",
    "email": "analsandblaster@gmail.com"
  },
  "name": "logule",
  "description": "An advanced console logging library",
  "version": "0.9.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/clux/logule.git"
  },
  "main": "logule.js",
  "engines": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "test": "tap ./test"
  },
  "dependencies": {
    "colors": "~0.5.1",
    "autonomy": "~0.2.0",
    "subset": "~0.1.0",
    "confortable": "~0.1.4",
    "semver": "~1.0.13"
  },
  "devDependencies": {
    "tap": "~0.2.5"
  },
  "bugs": {
    "url": "http://github.com/clux/logule/issues"
  },
  "license": "MIT",
  "optionalDependencies": {},
  "readme": "# Logule [![Build Status](https://secure.travis-ci.org/clux/logule.png)](http://travis-ci.org/clux/logule)\n\nLogule is a heavily configurable logging utility for nodejs. By default it prints only to stdout like `console.log`, but additionally it prefixes the current time, the log level, and optionally, prefixed namespaces (with optional padding). A log file can also be configured to stream JSON formatted log messages to a file for inspection of the raw data via short scripts.\n\nShortcut methods for the log levels are available as (by default): `log.error`, `log.warn`, `log.info`, `log.debug`, `log.trace`, `log.zalgo`, and as a bonus, `log.line`. These methods are additionally chainable.\n\nIt favours a combination of Dependency Injection and config based control to allow for both tree-based log level filtration (via DI), and globally controllable log levels (via config files).\n\n## Usage\nBasic usage:\n\n````javascript\nvar logule = require('logule');\nlogule\n  .error(\"this is an error message\")\n  .warn(\"warning\")\n  .info(\"info msg\")\n  .debug(\"chained debug\");\n````\n\n![simple output!](https://github.com/clux/logule/raw/master/imgs/outputsimple.png)\n\n## Namespaces\nTo add a namespace prefix, subclass logule with it:\n\n````javascript\nlog = logule.sub('BUILD');\nlog.trace(\"Trying to compile main.js\");\nlog.error(\"Failed\");\nlogule.info(\"Shutting down\")\n````\n\n![one namespace output!](https://github.com/clux/logule/raw/master/imgs/output.png)\n\n### Multiple Namespaces\nPass in more strings to get more namespaces prefixed\n\n````javascript\nvar log = logule.sub('BUILD', 'COMPILE');\nlog.debug('log has two prefixes');\n````\n\n### Namespace Padding\nCall `.pad(size)` on a logger instance to specify a fixed indentation level for each namespace.\n\n````javascript\nlog.pad(16);\nlog.warn('my namespaces are padded');\n````\n\nMessages will here begin `(16 + delimiter_size)*num_namespaces` characters out.\nLarge namespaces (>specified size), will stand out from the crowd.\n\n## Line\nAn awesome feature inspired by [nlogger](https://github.com/igo/nlogger) - but using logule\nsemantics; `logule.line()` reads the line and filename of the calling function\nby directly inspecting the stack.\n\n````javascript\nlog = logule.sub('CRAZYDEBUG');\nlog.debug('dumping lines to console');\nlog.line('who called me?');\nlog.line('and now?');\n```\n\n![line output!](https://github.com/clux/logule/raw/master/imgs/line.png)\n\n## Passing log around\n### Dependency Injection\n#### Subclasses\nA good use of `.sub()` involve inheriting based on namespaces, and linking\ninstances together.\n\n````javascript\nvar log = logule.sub('BUILD');\nvar sublog = log.sub('COMPILE');\n````\n\nHere `sublog` would provide same output as `logule.sub('BUILD', 'COMPILE')`.\n\nIt is advantageous to do 'one namespace sub at a time', as then it is easier\nto filter log output from large chunks of code at a time,\nas well as maintaining a sensible log hierarchy.\n\nA `log.sub()` maintains all padding, suppressed log levels, its locked status,\nand namespace properties set on the original `log` instance. Therefore, it works as if there's\nan implicit link between the sub and its parent.\n\n#### Suppress\nSuppressing logs from an instance is done in a very neat, propagating,\nand non-breaking way. `.suppress(methods...)` suppresses output\nfrom specified methods, but still allows them to be called, and they still chain.\n\n````javascript\nlog.suppress('debug', 'info');\nlog.warn('works').info('suppressed').error('works').debug('suppressed');\n````\n\nAll subclasses subsequently created from a suppressed instance,\nwill also be suppressed. To unsuppress, use `.allow()`.\n\n#### Allow\nAllows modules down in the hierarchy to log things that have been suppressed\nby supers. This only works if global log levels have not been enforced.\n\n````javascript\nlog.suppress('debug', 'info');\nvar l2 = log.sub('forModuleX');\nl2.allow('debug');\nl2.debug('works!')\n````\n\n#### Get Method\nA debug module should only need `log.debug`. You can save typing,\nand enforce this behaviour by calling `.get('debug')` on an instance,\nto return the correctly bound instance method to pass down.\n\n````javascript\nvar dbg = log.get('debug');\ndbg(\"works like log.debug - nothing else accessible through this var\");\n````\n\nNote that if `log` have called `.suppress('debug')` earlier - or if it is a `.sub()`\nof an instance that have called `.suppress('debug')`, then you would only get\na suppressed function from `.get('debug')`.\n\n### Tree Based Log Levels\nBy only using `.sub()` instances inheriting from a single base instance,\nyou can implement tree based log levels at start time by calling\n`.suppress()` and `.allow()` on the base instance - or any branch point\nyou would like.\n\n````javascript\nvar log = logule.sub('APP');\n//log.suppress('info','debug'); // uncomment to globally suppress\n\nvar modelsLog = log.sub('MODEL'); // pass this to models\n//modelsLog.suppress('warn'); // uncomment to suppress warnings below\n\nvar eventsLog = modelsLog.sub('EVENT'); // pass this down from models to events\n//eventsLog.allow('debug'); // uncomment to temporarily allow debugs in this module\n````\n\nTree based log levels is the safe, overridable version of log levels.\nTo strictly enforce suppression of certain levels, use config files.\n\n## Configuration\nSince logule >= 0.7, rich configuration of colors, style, date formatting and global suppression of certain log levels is available. The [default configuration file](https://github.com/clux/logule/blob/master/.logule) results in output looking like the older versions.\n\nWhen starting a node script requiring logule, logule will search from the execution directory for a `.logule` file. If that fails, it will keep searching one directory up until $HOME is hit.\n\nIf no config is found, one final search is done in the parent's (the module that requires logule) directory, and the resulting config is merged carefully with the default one bundled with logule.\n\n### Stream JSON\nIf `logFile` is set in `.logule`, this file will be appended to with JSON log messages (one message per line). Thus, you can read the file and split by newline, or watch the file and emit/filter based on each JSON line you receive.\n\nThe individual JSON messages use the current format (here prettified):\n\n````javascript\n{\n  \"date\": \"08:14:11\",\n  \"level\": \"error\",\n  \"namespaces\": [\"build\"],\n  \"message\": \"message part, how it appeared in terminal\"\n}\n````\n\n### Config Ideas\n#### Custom Prototype Log Methods\nConfig files can fully reconfigure/add new log methods with your own names. The prototype methods created will be directly taken from the level object in the config file, and these will log with the specified color and with the same (upper cased in print) level. Note that you can not remove the original methods (only suppress them) as to do so would break DI.\n\nNote that `line` which will additionally include the file and line of callsite when used, and `zalgo` will have some idiosyncratic formatting.\n\n#### Global Filtration\nSet the `suppress` flag to globally turn all listed log methods into chaining no-ops.\nIf most methods listed should be disabled, quickly list the exceptions under the `allow` flag and set `useAllow` to `true`.\n\n\n## Verifying Logule Validity\nWhen passing logule subs around, it might be useful for separate code to test\nwhether what is received is an appropriate Logule instance or not.\nUnfortunately, instanceof testing against your installed logule will only work\nwhen your code is not separated into modules.\n\nTherefore, to support npm module style where there are possibly multiple installations\nof logule spread around, the module can test that the one passed in,\nhas a version compatible with the module's own using a built in helper function.\n\n````javascript\nvar logule = require('logule');\nfunction (injectedLogule) {\n  if (logule.verify(injectedLogule)) {\n    // injectedLogule exists, and its version is ~ to the module's own\n  } else {\n    // injectedLogule invalid or out of date: use logule\n  }\n}\n````\n\nNote that single functions like `logule.get('info')` will of course not pass this test.\nIf your API expects a single logger function, then\nyou should simply type test the input as a function.\n\n\n## Zalgo\nH̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝S̨̥̫͎̭ͯ̿̔̀ͅ\n\n````javascript\nlog.zalgo(\"all is lost\");\n````\n\n## Installation\n\n````bash\n$ npm install logule\n````\n\n## Running tests\nInstall development dependencies\n\n````bash\n$ npm install\n````\n\nRun the tests\n\n````bash\n$ npm test\n````\n\n## License\nMIT-Licensed. See LICENSE file for details.\n",
  "_id": "logule@0.9.1",
  "_from": "logule"
}
